"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const amqplib = require("amqplib");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const uuid = require("uuid");
const DIRECT_REPLY_QUEUE = 'amq.rabbitmq.reply-to';
const defaultConfig = {
    timeout: 10000,
    prefetchCount: 10,
    defaultExchangeType: 'topic'
};
class AmqpConnection {
    constructor(config) {
        this.messageSubject = new rxjs_1.Subject();
        this.config = Object.assign({}, defaultConfig, config);
    }
    get channel() {
        return this._channel;
    }
    get connection() {
        return this._connection;
    }
    async init() {
        this._connection = await amqplib.connect(this.config.uri);
        this._channel = await this._connection.createChannel();
        await Promise.all(this.config.exchanges.map(async (x) => this._channel.assertExchange(x.name, x.type || this.config.defaultExchangeType, x.options)));
        await this.initDirectReplyQueue();
    }
    async request(messageOptions, payload) {
        const correlationId = uuid.v4();
        const response$ = this.messageSubject.pipe(operators_1.filter(x => x.correlationId === correlationId), operators_1.map(x => x.message), operators_1.first());
        this.publish(messageOptions.exchange, messageOptions.routingKey, payload, {
            replyTo: DIRECT_REPLY_QUEUE,
            correlationId
        });
        const timeout$ = rxjs_1.interval(this.config.timeout).pipe(operators_1.first(), operators_1.map(x => {
            throw new Error(`Failed to receive response within timeout of ${this.config.timeout}ms`);
        }));
        return rxjs_1.race(response$, timeout$).toPromise();
    }
    async createSubscriber(handler, msgOptions) {
        const { exchange, routingKey } = msgOptions;
        const { queue } = await this.channel.assertQueue(msgOptions.queue || '');
        await this.channel.bindQueue(queue, exchange, routingKey);
        await this.channel.consume(queue, async (msg) => {
            if (msg == null) {
                throw new Error('Received null message');
            }
            const message = JSON.parse(msg.content.toString());
            await handler(message);
            this._channel.ack(msg);
        });
    }
    async createRpc(handler, msgOptions) {
        const { exchange, routingKey } = msgOptions;
        const { queue } = await this.channel.assertQueue(msgOptions.queue || '');
        await this.channel.bindQueue(queue, exchange, routingKey);
        await this.channel.consume(queue, async (msg) => {
            if (msg == null) {
                throw new Error('Received null message');
            }
            const message = JSON.parse(msg.content.toString());
            const response = await handler(message);
            const { replyTo, correlationId } = msg.properties;
            this.publish('', replyTo, response, { correlationId });
            this._channel.ack(msg);
        });
    }
    publish(exchange, routingKey, message, options) {
        this.channel.publish(exchange, routingKey, Buffer.from(JSON.stringify(message)), options);
    }
    async initDirectReplyQueue() {
        // Set up a consumer on the Direct Reply-To queue to facilitate RPC functionality
        await this._channel.consume(DIRECT_REPLY_QUEUE, async (msg) => {
            if (msg == null) {
                return;
            }
            const correlationMessage = {
                correlationId: msg.properties.correlationId.toString(),
                message: JSON.parse(msg.content.toString())
            };
            this.messageSubject.next(correlationMessage);
        }, {
            noAck: true
        });
    }
}
exports.AmqpConnection = AmqpConnection;
//# sourceMappingURL=AmqpConnection.js.map