"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const amqplib = require("amqplib");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const uuid = require("uuid");
const rabbitmq_interfaces_1 = require("../rabbitmq.interfaces");
const handlerResponses_1 = require("./handlerResponses");
const DIRECT_REPLY_QUEUE = 'amq.rabbitmq.reply-to';
const defaultConfig = {
    prefetchCount: 10,
    defaultExchangeType: 'topic',
    defaultRpcErrorBehavior: rabbitmq_interfaces_1.MessageHandlerErrorBehavior.REQUEUE,
    defaultSubscribeErrorBehavior: rabbitmq_interfaces_1.MessageHandlerErrorBehavior.REQUEUE,
    exchanges: [],
    defaultRpcTimeout: 10000
};
class AmqpConnection {
    constructor(config) {
        this.messageSubject = new rxjs_1.Subject();
        this.config = Object.assign({}, defaultConfig, config);
    }
    get channel() {
        return this._channel;
    }
    get connection() {
        return this._connection;
    }
    async init() {
        this._connection = await amqplib.connect(this.config.uri);
        this._channel = await this._connection.createChannel();
        await Promise.all(this.config.exchanges.map(async (x) => this._channel.assertExchange(x.name, x.type || this.config.defaultExchangeType, x.options)));
        await this.channel.prefetch(this.config.prefetchCount);
        await this.initDirectReplyQueue();
    }
    async request(requestOptions) {
        const correlationId = uuid.v4();
        const timeout = requestOptions.timeout || this.config.defaultRpcTimeout;
        const payload = requestOptions.payload || {};
        const response$ = this.messageSubject.pipe(operators_1.filter(x => x.correlationId === correlationId), operators_1.map(x => x.message), operators_1.first());
        this.publish(requestOptions.exchange, requestOptions.routingKey, payload, {
            replyTo: DIRECT_REPLY_QUEUE,
            correlationId
        });
        const timeout$ = rxjs_1.interval(timeout).pipe(operators_1.first(), operators_1.map(x => {
            throw new Error(`Failed to receive response within timeout of ${timeout}ms`);
        }));
        return rxjs_1.race(response$, timeout$).toPromise();
    }
    async createSubscriber(handler, msgOptions) {
        const { exchange, routingKey } = msgOptions;
        const { queue } = await this.channel.assertQueue(msgOptions.queue || '', msgOptions.queueOptions || undefined);
        await this.channel.bindQueue(queue, exchange, routingKey);
        await this.channel.consume(queue, async (msg) => {
            try {
                if (msg == null) {
                    throw new Error('Received null message');
                }
                let message = {};
                try {
                    message = JSON.parse(msg.content.toString());
                }
                catch (e) {
                    // The message passed over RabbitMQ could not be converted to JSON
                    // This isn't necessarily an error and should be revisited in future releases
                    // 这里可能不是json格式，比如protobuf格式
                    // 先直接使用try进行捕获，合理的方案应该是直接在
                    // 注解的部分声明消息类型，然后消息进行透明回传，由业务放进行转码，框架默认不处理转码编码部分
                }
                const response = await handler(message, msg);
                if (response instanceof handlerResponses_1.Nack) {
                    this._channel.nack(msg, false, response.requeue);
                    return;
                }
                if (response) {
                    throw new Error('Received response from subscribe handler. Subscribe handlers should only return void');
                }
                this._channel.ack(msg);
            }
            catch (e) {
                if (msg == null) {
                    return;
                }
                else {
                    const errorBehavior = msgOptions.errorBehavior ||
                        this.config.defaultSubscribeErrorBehavior;
                    switch (errorBehavior) {
                        case rabbitmq_interfaces_1.MessageHandlerErrorBehavior.ACK: {
                            this._channel.ack(msg);
                            break;
                        }
                        case rabbitmq_interfaces_1.MessageHandlerErrorBehavior.REQUEUE: {
                            this._channel.nack(msg, false, true);
                            break;
                        }
                        default:
                            this._channel.nack(msg, false, false);
                    }
                }
            }
        });
    }
    async createRpc(handler, rpcOptions) {
        const { exchange, routingKey } = rpcOptions;
        const { queue } = await this.channel.assertQueue(rpcOptions.queue || '', rpcOptions.queueOptions || undefined);
        await this.channel.bindQueue(queue, exchange, routingKey);
        await this.channel.consume(queue, async (msg) => {
            try {
                if (msg == null) {
                    throw new Error('Received null message');
                }
                const message = JSON.parse(msg.content.toString());
                const response = await handler(message, msg);
                if (response instanceof handlerResponses_1.Nack) {
                    this._channel.nack(msg, false, response.requeue);
                    return;
                }
                const { replyTo, correlationId } = msg.properties;
                if (replyTo) {
                    this.publish('', replyTo, response, { correlationId });
                }
                this._channel.ack(msg);
            }
            catch (e) {
                if (msg == null) {
                    return;
                }
                else {
                    const errorBehavior = rpcOptions.errorBehavior || this.config.defaultRpcErrorBehavior;
                    switch (errorBehavior) {
                        case rabbitmq_interfaces_1.MessageHandlerErrorBehavior.ACK: {
                            this._channel.ack(msg);
                            break;
                        }
                        case rabbitmq_interfaces_1.MessageHandlerErrorBehavior.REQUEUE: {
                            this._channel.nack(msg, false, true);
                            break;
                        }
                        default:
                            this._channel.nack(msg, false, false);
                    }
                }
            }
        });
    }
    publish(exchange, routingKey, message, options) {
        this.channel.publish(exchange, routingKey, Buffer.from(JSON.stringify(message)), options);
    }
    async initDirectReplyQueue() {
        // Set up a consumer on the Direct Reply-To queue to facilitate RPC functionality
        await this._channel.consume(DIRECT_REPLY_QUEUE, async (msg) => {
            if (msg == null) {
                return;
            }
            const correlationMessage = {
                correlationId: msg.properties.correlationId.toString(),
                message: JSON.parse(msg.content.toString())
            };
            this.messageSubject.next(correlationMessage);
        }, {
            noAck: true
        });
    }
}
exports.AmqpConnection = AmqpConnection;
//# sourceMappingURL=connection.js.map